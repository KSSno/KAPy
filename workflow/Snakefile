# KAPy Workflow
#
# This snakemake workflow handles the processing of data for use
# in Klimaatlas-like products. 
#
# The pipeline can be run using
#    > snakemake --cores 1 <target>
#
# A list of available target rules can be obatined using
#   > snakemake -S
#
# Workflow configuration options are set in config.yaml
#

import KAPy
import os

#Setup-----------------------
#Load configuration 
config=KAPy.loadConfig()
outDirs=config['dirs']

#Generate filename dicts
wf=KAPy.getWorkflow(config)

# Primary Variables---------------------------------
#Primary variable singular rule
def primVar_singular_rule(thisID):
    rule:  
        name: f'primVar_{thisID}_files'
        output:
            os.path.join(outDirs['primVars'],"{pvFname}")
        input:
            lambda wildcards: 
                wf['primVars'][thisID][ os.path.join(outDirs['primVars'],wildcards.pvFname)]
        run:
            KAPy.buildPrimVar(config=config,
                                     inFiles=input,
                                     outFile=output,
                                     inpID=thisID)

#Plural rule
def primVar_plural_rule(thisID):
    rule:
        name: f'primVar_{thisID}'
        input:
            list(wf['primVars'][thisID].keys())
            
for inpID in wf['primVars'].keys():
    primVar_singular_rule(inpID)
    primVar_plural_rule(inpID)

#Run all indicators    
rule primVars:
    input:
        [list(thisInp.keys()) for thisInp in wf['primVars'].values()]
        

# Secondary variables -------------------------
# "Secondary variables" are calculated as new variables derived from primary variables.  
# Good examples include FWI, PoteEvap and SPI. 
# Singular rule
def secVar_singular_rule(thisID):
    rule:  
        name: f'secVar_{thisID}_files'
        output:
            os.path.join(outDirs['secVars'],"{svFname}")
        input:
            lambda wildcards: 
                wf['secVars'][thisID][ os.path.join(outDirs['secVars'],wildcards.svFname)].values()
        run:
            KAPy.buildDerivedVar(config=config,
                                     inFiles=wf['secVars'][thisID][output[0]], 
                                     outFile=output,
                                     thisVar=config['secondaryVars'][thisID])

#Plural rule
def secVar_plural_rule(thisID):
    rule:
        name: f'secVar_{thisID}'
        input:
            list(wf['secVars'][thisID].keys())
            
for inpID in wf['secVars'].keys():
    secVar_singular_rule(inpID)
    secVar_plural_rule(inpID)

#Run all plurals    
rule secVars:
    input:
        [list(thisVar.keys()) for thisVar in wf['secVars'].values()]
        

"""
#Variables---------------------------------
#Rules for primary and secondary variables can be generated using a generic set of rules
#Singular rule
def var_singular_rule(varType,thisID):
    rule:  
        name: f'{varType}_{thisID}_files'
        output:
            os.path.join(outDirs[varType],"{varFname}")
        input:
            lambda wildcards: 
                wf[varType][thisID][ os.path.join(outDirs[varType],wildcards.varFname)] \
                if varType=="primVar" else \
                wf[varType][thisID][ os.path.join(outDirs[varType],wildcards.varFname)].values()
        run:
            if varType=="primVar":
                KAPy.buildPrimVar(config=config,
                                         inFiles=input,
                                         outFile=output,
                                         inpID=thisID)
            else:
                KAPy.buildDerivedVar(config=config,
                                         inFiles=input,
                                         outFile=output,
                                         inpID=config[varType][thisID])

#Plural rule
def var_plural_rule(varType,thisID):
    rule:
        name: f'{varType}_{thisID}'
        input:
            list(wf[varType][thisID].keys())
            
#Lumped rule
def var_lumped(varType):
    rule:  
        name: f'{varType}'
        input:
            [list(thisVar.keys()) for thisVar in wf[varType].values()]
            
for varType in ['primVars','secVars']:
    var_lumped(varType)
    for varID in wf[varType].keys():
        var_singular_rule(varType,varID)
        var_plural_rule(varType,varID)

"""
        
# Bias correction -------------------
# TODO


# Indicators ---------------------------------
# Create a loop over the indicators that defines the singular and plural rules
# as well as the combined run

#Indicator singular rule
def ind_singular_rule(thisID):
    rule:  
        name: f'indicator_{thisID}_files'
        output:
            os.path.join(outDirs['indicators'],"{indFname}")
        input:
            lambda wildcards: 
                wf['indicators'][thisID][ os.path.join(outDirs['indicators'],wildcards.indFname)]
        run:
            KAPy.calculateIndicators(config=config,
                                     inFile=input,
                                     outFile=output,
                                     indID=thisID)
                                     

#Indicator plural rule
def ind_plural_rule(thisID):
    rule:
        name: f'indicator_{thisID}'
        input:
            list(wf['indicators'][thisID].keys())
            
for indID in config['indicators'].keys():
    ind_singular_rule(indID)
    ind_plural_rule(indID)

#Run all indicators    
rule indicators:
    input:
        [list(thisInd.keys()) for thisInd in wf['indicators'].values()]

# Regridding  ---------------------------------
# Combining everything into an ensemble requires that they are all on a common grid
# This step is optional but if the models are not on a common grid, this will cause failure 
# when we come to the ensstats generation
if config['outputGrid']['regriddingEngine']!='None':
    rule regrid:
        input:
            list(wf['regridded'].keys())

    rule regrid_file:
        output:
            os.path.join(outDirs['regridded'],"{rg}")
        input:
            lambda wildcards: wf['regridded'][os.path.join(outDirs['regridded'],wildcards.rg)]
        run:
            KAPy.regrid(config,input,output)

# Enssemble Statistics ---------------------------------
# Now we can combine them into ensembles
#Plural rule
rule ensstats:
    input:
        list(wf['ensstats'].keys())

#Singular rule
rule ensstats_file:
    output:
        os.path.join(outDirs['ensstats'],"{es}")
    input:
        lambda wildcards: wf['ensstats'][os.path.join(outDirs['ensstats'],wildcards.es)]
    run:
        KAPy.generateEnsstats(config,input,output)


#Areal statistics------------------
#Areal statistics can be calculated for both the enssemble statistics and the
#individual ensemble members - these options can be turned on and off as required
#via the configuration options. 
#Plural rule
rule arealstats:
    input:
        list(wf['arealstats'].keys())

#Singular rule
rule arealstats_file:
    output:
        os.path.join(outDirs['arealstats'],'{arealstats}')
    input:
        lambda wildcards: wf['arealstats'][os.path.join(outDirs['arealstats'],wildcards.arealstats)]
    run:
        KAPy.generateArealstats(config,input,output)

# Outputs ---------------------------------
# Notebooks, amongst other things
#Plural rule
rule notebooks:
    input:
        list(wf['notebooks'].keys())

#Singular rule
rule notebook_file:
    output:
        os.path.join(outDirs['notebooks'],'{notebook}')
    input:
        lambda wildcards: wf['notebooks'][os.path.join(outDirs['notebooks'],wildcards.notebook)]
    shell:
        "jupyter nbconvert --execute --to html --TemplateExporter.exclude_input=True --output-dir=. --output='{output}' {input[0]}"


#All-------------------
rule all:
    input:
        wf['all']
    default_target: True

